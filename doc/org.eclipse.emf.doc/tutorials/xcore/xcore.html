<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<title>Xcore Overview</title>
	<link rel="stylesheet" href="images/../../../css/book.css" type="text/css" />
	<link rel="stylesheet" href="images/../../../css/emf-book.css" type="text/css" />
</head>

<body lang="EN-US" xml:lang="EN-US">

	<div align="left">
		<h1><img src="images/XcoreLogo.png" align="middle" width="120" height="120" alt="" /></h1>
	</div>

	<h1 align="center">Xcore Comprehensive Overview</h1>

	<blockquote>
		<strong><big>Summary</big></strong>
		<br />
		<p>
			Xcore is an extended concrete syntax for Ecore that,
			in combination with <a href="https://eclipse.dev/Xtext/">Xbase</a>,
			transforms it into a fully fledged programming language with high quality tools reminiscent of the Java Development Tools.
			You can use it not only to specify the structure of your model,
			but also the behavior of your operations and derived features as well as the conversion logic of your data types.
			It eliminates the dividing line between modeling and programming,
			combining the advantages of each. All this is supported for both generated and dynamic
			EMF models.
		</p>
	</blockquote>

	<hr width="100%" />

	<h2>Contents</h2>
	<ol>
		<li><a href="#Creating_an_Xcore_Project"> <span>Creating an Xcore Project</span></a></li>
		<li><a href="#Creating_an_Xcore_model"> <span>Creating an Xcore model</span></a>
			<ol>
				<li><a href="#Specifying_a_Package"> <span>Specifying a Package</span></a></li>
				<li><a href="#Specifying_a_Class"> <span>Specifying a Class</span></a></li>
				<li><a href="#Specifying_an_Attribute"> <span>Specifying an Attribute</span></a></li>
				<li><a href="#Specifying_a_Containment_Reference"> <span>Specifying a Containment Reference</span></a></li>
				<li><a href="#Specifying_a_Container_Reference"> <span>Specifying a Container Reference</span></a></li>
				<li><a href="#Specifying_a_Cross_Reference"> <span>Specifying a Cross Reference</span></a></li>
				<li><a href="#Specifying_an_Enumeration"> <span>Specifying an Enumeration</span></a></li>
				<li><a href="#Specifying_a_Data_Type"> <span>Specifying a Data Type</span></a></li>
				<li><a href="#Specifying_an_Operation"> <span>Specifying an Operation</span></a></li>
				<li><a href="#Specifying_a_Derived_Feature"> <span>Specifying a Derived Feature</span></a></li>
				<li><a href="#Implementing_an_Interface"> <span>Implementing an Interface</span></a></li>
				<li><a href="#Specifying_an_Annotation"> <span>Specifying an Annotation</span></a></li>
			</ol>
		</li>
		<li><a href="#Creating_an_ESON_Textual_Instance"> <span>Creating an ESON Textual Instance</span></a></li>
		<li><a href="#Creating_a_Dynamic_Instance"> <span>Creating a Dynamic Instance</span></a></li>
		<li><a href="#Configuring_GenModel_Properties"> <span>Configuring GenModel Properties</span></a></li>
		<li><a href="#Converting_a_GenModel_to_an_Xcore_Model"> <span>Converting a GenModel to an Xcore Model</span></a></li>
		<li<a href="#Converting_an_Xcore_Model_to_a_GenModel"> <span>Converting an Xcore Model to a GenModel</span></a></li>
	</ol>

	<h2><span id="Creating_an_Xcore_Project">Creating an Xcore Project</span></h2>
	<p>
		Xcore can be used in any properly-configured Java project.
		There's a convenient wizard for creating an empty pre-configured project.
	</p>
	<ul>
		<li>Use <code>File &#8594; Project...</code> and enter <code>Xcore</code> in the filter field or locate <code>Xcore &#8594; Xcore Project</code>.</li>
		<li>
			Use <code>Next</code> to advance the "New Project" wizard and enter the name of your project.
			It's best to use a qualified name that will be appropriate as a plug-in ID and as a prefix for your Java packages, i.e, org.example.library.
		</li>
		<li>Use <code>Finish</code> to complete the wizard.</li>
	</ul>
	<p>In your workspace you'll see your new project.
	</p>
	<img alt="XcoreNewlyCreatedLibraryProject.png" src="images/XcoreNewlyCreatedLibraryProject.png">

	<p>
		It's a project with a Java, PDE, and <a href="https://eclipse.dev/Xtext/">Xtext</a> natures that contains the following:
	</p>
	<ul>
		<li> A <code>src</code> folder for your hand written Java code.</li>
		<li> A <code>src-gen</code> folder in which your model code will be generated by default.</li>
		<li> A <code>MANIFEST.MF</code> with prepopulated dependencies for EMF Ecore and Xtext Xbase.</li>
		<li> And an empty <code>model</code> folder.</li>
	</ul>

	<p>
		Of course it's possible to start with any Java project and use the <code>Convert &#8594; Add Xtext Nature</code> or <code>Convert &#8594; Convert to Plug-in Projects</code>
		to introduce the missing natures and to edit the <code>MANIFEST.MF</code> to add missing dependencies.
	</p>

	<h2><span id="Creating_an_Xcore_model">Creating an Xcore model</span></h2>
	<p>
		An Xcore model is created in the <code>model</code> folder via its context menu using <code>New &#8594; File</code> to create an empty new file with extension <code>.xcore</code>,
		e.g., <code>Company.xcore</code>.
		This will open the Xcore-aware editor.
		It starts out with an error marker, because an empty file isn't a valid Xcore instance.
	</p>

	<h3><span id="Specifying_a_Package">Specifying a Package</span></h3>
	<p>
		The editor supports syntax completion so if you enter <code>Ctrl-Space</code>, you'll see it fills in the <code>package</code> keyword.
		Next you need to enter a package name, e.g., <code>org.example.company</code>.
		If you save, you'll see the error markers go away.
		You've created an empty Xcore package. Files <code>build.properties</code>, <code>plugin.properties</code> and <code>plugin.xml</code>
		are automatically created at the top level of the project during the save.
		As you can see, like Java, an Xcore model starts with a package declaration but note that that there's no semicolon.
		Note too that nothing is generated in the <code>src-gen</code> folder yet; EMF doesn't generate anything for empty packages.
	</p>
	<img alt="XcoreNewPropertiesAndXMLFilesCreatedOnSave.png" src="images/XcoreNewPropertiesAndXMLFilesCreatedOnSave.png">

	<h3><span id="Specifying_a_Class">Specifying a Class</span></h3>
	<p>
		Now you're ready to create something more meaningful.
		Add two blank lines and try hitting <code>Ctrl-Space</code> again to see what you're allowed to enter next.
	</p>
	<img alt="XcoreTopLevelSyntaxCompletion.png" src="images/XcoreTopLevelSyntaxCompletion.png">

	<p>
		We'll start by defining a class called <code>Library</code>.
		After entering the <code>class</code> keyword and the name of the class, type a curly brace: the closing curly brace is automatically inserted.
		If you now save the editor, you'll see the following:
	</p>
	<img alt="XcoreEmptyLibraryClass.png" src="images/XcoreEmptyLibraryClass.png">

	<p>
		Notice that the model code has been generated automatically.
	</p>

	<h3><span id="Specifying_an_Attribute">Specifying an Attribute</span></h3>
	<p>
		Now you're ready to define the structure of the <code>Library</code> class.
		Within the curly braces, hit <code>Ctrl-Space</code> to see what you're allowed to enter next.
	</p>
	<img alt="XcoreClassLevelSyntaxCompletion.png" src="images/XcoreClassLevelSyntaxCompletion.png">

	<p>
		To specify an attribute, you need to specify the name of a data type followed by the name of the feature.
		So if you choose <code>String</code>, enter <code>name</code>, and save, you'll see the following:
	</p>
	<img alt="XcoreAttributeDefinition.png" src="images/XcoreAttributeDefinition.png">

	<p>
		Of course the corresponding feature accessor methods, i.e., <code>getName()</code> and <code>setName(String)</code>, will immediately be generated in the <code>Library</code> interface.
		Note that while the Xcore source shows the use of <code>String</code>,
		which in the completion proposal you saw earlier was listed as <code>java.lang.String</code>,
		from the hover information you can see that the reference actually resolves to the <code>EString</code> data type from the built-in <code>Ecore</code> package.
		Xcore provides familiar aliases for all of the Ecore data types that correspond to Java built-in and mathematical types.
		If your attribute is a reserved word such as <code>type</code> or <code>id</code>,
		you will need to escape it with a <code>^</code>.
		For example: <code>String ^type</code>.
	</p>
	<pre>class Library
{
  int ^id
  String ^type
}
</pre>
	<p>
		If you need to specify a default value for an attribute, you can use the following syntax:
	</p>
	<pre>class Library
{
  String name = "Default Name"
  boolean stateOwned = "true"
}
</pre>
	<p>
		In the above example, the string after the equals sign will be used to populate the <code>Default Value Literal</code> property of the Ecore feature.
		Thus, the generated Java implementation code will contain:
	</p>
	<pre>public class LibraryImpl ...
{
  protected static final String NAME_EDEFAULT = "Default Name";
  protected static final boolean STATE_OWNED_EDEFAULT = true;
  ...
}
</pre>

	<h3><span id="Specifying_a_Containment_Reference">Specifying a Containment Reference</span></h3>
	<p>
		We'll want libraries to contain books and authors, so let's add two more empty classes, <code>Book</code> and <code>Writer</code> so that we can specify references to them in the library.
		If we try the same approach as defining the name feature, you'll end up with the following:
	</p>
	<img alt="XcoreAttributeWithClassTypeError.png" src="images/XcoreAttributeWithClassTypeError.png">
	<p>
		That's because Xcore interprets this as an attribute and the type of an attribute must be a data type, not a class.
		If you hover over the error indicator, you'll see how to fix the problem.
	</p>
	<img alt="XcoreAttributeWithClassTypeErrorQuickFix.png" src="images/XcoreAttributeWithClassTypeErrorQuickFix.png">

	<p>
		In this case, we want to define a containment reference, so choose that option.
		Notice that if you select the reference to <code>Book</code> you can use <code>F3</code> to navigate to the definition for the <code>Book</code> class.
		Of course we wanted to define this to be a multi-valued reference and here have specified a single-valued reference.
		The multiplicity of a feature is specified with the bounds in square brackets, where <code>[]</code> is used as a short-hand for <code>[0..*]</code> as follows:
	</p>
	<img alt="XcoreMuliValuedReference.png" src="images/XcoreMuliValuedReference.png">

	<p>
		Let's define another multi-valued containment reference called <code>authors</code> and save the result, which will look as follows:
	</p>
	<img alt="XcoreLibraryWithThreeFeatures.png" src="images/XcoreLibraryWithThreeFeatures.png">

	<p>
		Again, the expected results are immediately generated.
		Notice that the outline view uses icons are much like the GenModel's icons, though with a purplish cast rather than a bluish one.
	</p>

	<h3><span id="Specifying_a_Container_Reference">Specifying a Container Reference</span></h3>
	<p>
		If you wanted a convenient API for navigating from a <code>Book</code> or <code>Writer</code> to its containing <code>Library</code> you'd specify container reference with an opposite like this:
	</p>
	<img alt="XcoreContainerReferenceWithCompletion.png" src="images/XcoreContainerReferenceWithCompletion.png">

	<p>
		Notice that completion support is available for specifying the opposite.
		When you select a choice, the opposite is automatically updated to refer back.
	</p>
	<img alt="XcorePairedOppositeReferences.png" src="images/XcorePairedOppositeReferences.png">

	<p>
		Let's add a container feature for <code>Writer</code> as well,
		and let's define <code>title</code> and <code>pages</code> features for <code>Book</code> and a <code>name</code> feature for <code>Writer</code> to produce the following:
	</p>
	<img alt="XcorePartiallyCompleteLibraryModel.png" src="images/XcorePartiallyCompleteLibraryModel.png">

	<p>
		Note how we've made use of <code>int</code> as an alias for <code>EInt</code> to define the type for <code>pages</code>.
	</p>

	<h3><span id="Specifying_a_Cross_Reference">Specifying a Cross Reference</span></h3>
	<p>
		The most important thing left to complete the picture is specifying the bidirectional relationship between <code>Books</code> and <code>Writers</code>.
		Specifying a cross reference is done much like we did for containment and container references, but using the <code>refers</code> keyword.
		We start by specifying one of the two references,
		i.e, a <code>Book</code> has <code>authors</code>, then the other,
		i.e., a <code>Writer</code> has <code>books</code>,
		at which point we can also specify the opposite.
	</p>
	<img alt="XcoreCrossReferenceOppositeCompletion.png" src="images/XcoreCrossReferenceOppositeCompletion.png">

	<p>
		Notice that opposite completion is supported here as well and that upon completion, both opposites are properly paired.
	</p>
	<img alt="XcoreCrossReferenceCompletedOpposites.png" src="images/XcoreCrossReferenceCompletedOpposites.png">

	<p>
		Of course <code>F3</code> navigation is supported for the reference to an opposite.
	</p>

	<p>
		References can be declared with the <code>local</code> modifier keyword.
		That is equivalent to setting the Ecore <code>Resolve Proxies</code> attribute to <code>false</code>.
	</p>

	<h3><span id="Specifying_an_Enumeration">Specifying an Enumeration</span></h3>
	<p>
		Supposed we wanted to categorize the kinds of books we have in the library.
		We could specify an enumeration named <code>BookCategory</code> for that and use it to specify a feature named <code>bookCategory</code> in <code>Book</code> as follows:
	</p>
	<img alt="XcoreEnumeration.png" src="images/XcoreEnumeration.png">

	<p>
		If you want to specify the integer values for the enum:
	</p>
	<pre> enum BookCategory
 {
   Mystery = 0
   ScienceFiction = 1
   Biography = 2
 }
</pre>
	<p>If you want to specify the literal values for the enum:
	</p>
	<pre> enum BookCategory
 {
   Mystery as "M"
   ScienceFiction as "S"
   Biography as "B"
 }
</pre>

	<p>
		If you want to specify both the integer value and the literal values for the enum:
	</p>
	<pre> enum BookCategory
 {
   Mystery as "M" = 0
   ScienceFiction as "S" = 1
   Biography as "B" = 2
 }
</pre>
	<h3><span id="Specifying_a_Data_Type">Specifying a Data Type</span></h3>
	<p>
		Suppose we wanted to specify the copyright date of a book.
		Of course we could use <code>EDate</code> from Ecore, but its serialization format is more like date and time, so that might not exactly fit our needs.
		Instead we could define our own <code>Date</code> data type to wrap <code>java.util.Date</code> as follows:
	</p>
	<img alt="XcoreDataTypeCompletion.png" src="images/XcoreDataTypeCompletion.png">

	<p>
		A data type acts as a wrapper for an existing Java type, so the completion proposal supports choosing a Java class that matches the name we've started typing.
		Upon selection, an import is added, so we can use the short form of the name.
	</p>
	<img alt="XcoreDataTypeWithCompletedImport.png" src="images/XcoreDataTypeWithCompletedImport.png">

	<p>
		Because classifier names and Java type names can never be used interchangeably in any Xcore scope,
		it's not a conflict to import the Java name in a scope that also defines a classifier with the same name.
	</p>

	<p>
		So far everything we've shown are things you could do with Ecore directly,
		so we've only seen how Xcore provides a concise textual syntax for Ecore.
		To complete the support for our own <code>Date</code> type,
		it would normally be necessary to modify the generated <code>LibraryFactoryImpl</code> class' methods that implement string conversion for this data type.
		With Xcore, we can specify this logic directly in the model.
		Note that if we look at the proposals for what may follow the type specification,
		we can see that the <code>create</code> and <code>convert</code> keywords are expected.
	</p>
	<img alt="XcoreDataTypeCreateMethodCompletionProposal.png" src="images/XcoreDataTypeCreateMethodCompletionProposal.png">

	<p>
		So we can choose to start specifying the <code>create</code> logic for creating an instance of the data type from a <code>String</code> value which is specifying within the curly braces of a block.
		We can using Java's <code>java.text.SimpleDateFormat</code> class as follows:
	</p>
	<img alt="XcoreDataTypeCreateMethodConstructorCompletion.png" src="images//XcoreDataTypeCreateMethodConstructorCompletion.png">

	<p>
		Notice that completion proposals understand what's on the classpath so we can use that for calling the constructor.
		To refer to the instance of the data type within the body we use "it", which acts much like the implicit <code>this</code> variable in Java.
		We also need to consider that <code>parse</code> can throw a <code>ParseException</code> that we need to handle properly.
		In addition, the value of the data type might be null, so best we guard for that case too.
		And finally, we can use a similar approach to specify the <code>convert</code> logic to produce the following complete result:
	</p>
	<img alt="XcoreBookWithCopyrightAttribute.png" src="images/XcoreBookWithCopyrightAttribute.png">

	<p>
		Notice we've also used the new data type to define a <code>copyright</code> feature in the <code>Book</code> class
		and that all the Java classes we've used were automatically imported by completion.
		The notation for expressing behavior in Xcore uses the model defined by Xbase.
		It's very similar to Java, but is expression oriented, so even things that are statements in Java, return a value in Xcore/Xbase.
		That's why you don't see a <code>return</code> statement.
	</p>

	<h3><span id="Specifying_an_Operation">Specifying an Operation</span></h3>
	<p>
		Suppose you wanted convenience methods on <code>Library</code>, e.g., an operation to retrieve a <code>Book</code> give its title.
		We could specify that as follows:
	</p>
	<img alt="XcoreOperationBodyForLoopCompletion.png" src="images/XcoreOperationBodyForLoopCompletion.png">

	<p>
		Again, the syntax is very Java-like and of course completion proposals are aware of the Java APIs implied by the Xcore model definition so feature names such as <code>books</code> are in the proposals.
		Here's how we would complete the definition:
	</p>
	<img alt="XcoreOperationComplete.png" src="images/XcoreOperationComplete.png">

	<p>
		We return <code>null</code> if we reach the end of the loop without a match.
		That's all there is to it.
		If you look at the generated implementation class for <code>Library</code> you'll see it compiles to the following Java code:
	</p>
	<img alt="XcoreCompiledOperation.png" src="images/XcoreCompiledOperation.png">

	<p>
		Notice that the <code>==</code> comparison for <code>title</code> is compiled to a null-safe <code>Object.equals</code> test.
		Notice also that all the things that look like simple field accesses in the Xcore code
		actually compile down to proper calls to the generated API accessor methods.
		One of the nice things about Xcore is that you get the advantages of writing what look like simple Java classes with simple fields declarations,
		including the ability to write a notation as if you had simple fields,
		but you end up with properly defined APIs and proper uses of them.
	</p>

	<p>
		To return Lists from operations,
		don't use the Java syntax but XCore syntax,
		e.g., <code>Book[] getBooks(String filter)</code> instead of <code>List&lt;Book&gt; getBooks()</code>.
	</p>

	<p>
		To have your operation return any Java type, define it as a Data Type first; see previous section.
	</p>

	<h3><span id="Specifying_a_Derived_Feature">Specifying a Derived Feature</span></h3>
	<p>
		With Xcore it's even possible to define the behavior of a derived feature.
		You only need to mark the feature as <code>derived</code> and, using the <code>get</code> keyword, define within a block how the value is completed.
		For example, you could specify a derived attribute to compute the last name of the <code>Writer</code> as follows:
	</p>
	<img alt="XcoreDerivedAttribute.png" src="images/XcoreDerivedAttribute.png">

	<h3><span id="Implementing_an_Interface">Implementing an Interface</span></h3>
	<p>
		If your class needs to implement an interface such as <code>java.lang.Iterable</code>, you wrap it just as you would a type.
		For examplexample:
	</p>
	<pre> type Iterator wraps Iterator&lt;EObject&gt;
 interface Iterable wraps java.lang.Iterable&lt;EObject&gt;
 {}
</pre>
	<pre> class MyClass extends Iterable
 {
   op Iterator iterator()
   {
     return new SpecialIterator();
   }
 }
</pre>

	<h3><span id="Specifying_an_Annotation">Specifying an Annotation</span></h3>

	<p>
		Ecore supports general-purpose annotations comprising a source string (typically a URI) for specifying identification
		and a map of string-based key-value pairs for specifying the details.
		Rather than requiring the typically large source URI to be repeated on each use,
		Xcore provide support for specifying a simple alias for it as follows:
	</p>
	<img alt="XcoreAnnotationDefinition.png" src="images/XcoreAnnotationDefinition.png">

	<p>
		We can then use it as follows:
	</p>
	<img alt="XcoreAnnotationUse.png" src="images/XcoreAnnotationUse.png">

	<p>
		Annotations with the GenModel's <code>nsURI</code> have specialized support in Xcore.
		Any key that matches the name of a feature in the GenModel, will be used to populate that feature.
		If you have a look at your generated model after saving the above,
		you will notice that the base class of each modeled class's implementation class has changed to use the one we've just specified.
	</p>
	<img alt="XcoreGenerateClassWithSpecifiedRootExtendsClass.png" src="images/XcoreGenerateClassWithSpecifiedRootExtendsClass.png">

	<p>
		Note that even the annotation definition itself is not necessary for this case because this "alias" is defined in <code>xcore.lang</code> and is therefore visible everywhere by default:
	</p>
	<img alt="XcoreLang.png" src="images/XcoreLang.png">

	<h2><span id="Creating_a_Dynamic_Instance">Creating a Dynamic Instance</span></h2>
	<p>
		Not only does Xcore generate you model code as you'd expect, everything we've specified works in dynamic models as well.
		Let's create a dynamic instance of <code>Library</code> by selecting it and bringing up the context menu for it as follows:
	</p>
	<img alt="XcoreCreateDynamicInstanceMenu.png" src="images/XcoreCreateDynamicInstanceMenu.png">

	<p>
		This brings up the following wizard, which lets you control the name and location of the new instance:
	</p>
	<img alt="XcoreCreateDynamicInstanceWizard.png" src="images/XcoreCreateDynamicInstanceWizard.png">

	<p>
		The defaults should be fine for now do drive the wizard to completion.
		This will open the <code>Sample Reflective Editor</code> as follows:
	</p>
	<img alt="XcoreDynamicLibraryInstance.png" src="images/XcoreDynamicLibraryInstance.png">

	<p>
		Expanding the first resource and double clicking on the <code>Library</code> instance will bring up the properties view.
		Notice that the <code>Library.xcore</code> resource is loaded in order to load the dynamic <code>Library</code> instance.
		If you expand it, you'll notice it contains the Xcore model, the GenModel, the Ecore model, and a bunch of JVM model instances.
		The GenModel and Ecore model are derived from the details in Xcore model.
		The various JVM model instances in turn are derived from the GenModel, i.e, all the information about the Java artifacts that are generated by the GenModel.
		Additional resources contain things that are referenced directly and indirectly from our model.
		Let's make the model more complete by creating a <code>Book</code>.
	</p>
	<img alt="XcoreCreateBookInstance.png" src="images/XcoreCreateBookInstance.png">

	<p>
		We can do the same thing to create a <code>Writer</code>.
		Let's have a look at the properties for a <code>Writer</code>.
		We can given the <code>Writer</code> a <code>Name</code>, say <code>Arthur C Clark</code> using the properties view.
	</p>
	<img alt="XcoreWriterSetName.png" src="images/XcoreWriterSetName.png">

	<p>
		Notice that the <code>Last Name</code> updates correctly whenever we change the full <code>Name</code>.
	</p>

	<p>
		Let's populate some of the information about the <code>Book</code>.
		We'll call it <code>2001: A Space Odyssey</code> and set the copyright date to <code>September 1st, 1968</code>.
	</p>
	<img alt="XcoreBookSetCopyright.png" src="images/XcoreBookSetCopyright.png">

	<p>
		Notice that as we start entering a date, we get feedback about parse failures demonstrating that the data type conversion logic we implemented is hard at work.
	</p>

	<p>
		Finally, we can have a look at how the logic for finding a book from its title is working in the <code>Library</code> instance.
		Let's select it and use <code>Windows &#8594; Show View &#8594; Other...</code> and locate <code>Eclipse Modeling Framework &#8594; Operation Invocation View</code>.
		This view responds to the selection in the active editor and provides a drop-down for choosing which operation to invoke.
		If the operation has arguments, it provides properties for setting those values.
		And of course there is an <code>Invoke</code> button for actually invoking the operation.
		We'd can use it as follows:
	</p>
	<img alt="XcoreLibraryOperationInvocation.png" src="images/XcoreLibraryOperationInvocation.png">

	<p>
		After invoking the operation, the result will be selected in the editor, so when the right book is selected, we can see that this too is working well.
	</p>

	<h2><span id="Configuring_GenModel_Properties">Configuring GenModel Properties</span></h2>
	<p>The Xcore editor directly supports the same <code>Properties</code> view as you're familiar with from the Generator.
		Use <code>Windows &#8594; Show View &#8594; Other...</code> followed by <code>General &#8594; Properties</code> to bring up the Properties view.
		It responds to selection it the editor and the <code>Outline</code>, so selecting the package produces the following:
	</p>
	<img alt="XcorePropertiesView.png" src="images/XcorePropertiesView.png">

	<p>
		Note that the properties for the GenModel and the GenPackage are merged into a single set of properties.
	</p>

	<p>
		Changing the values in the <code>Properties</code> view will modify the source with the corresponding <code>@GenModel</code> annotations.
	</p>
	<img alt="XcorePropertiesViewSettingEditDirectory.png" src="images/XcorePropertiesViewSettingEditDirectory.png">

	<p>
		If you save the Xcore resource now, you'll see that the <code>org.example.library.edit</code> project is created and the item providers are generated there.
	</p>
	<img alt="XcoreGeneratedEditProject.png" src="images/XcoreGeneratedEditProject.png">

	<h2><span id="Converting_a_GenModel_to_an_Xcore_Model">Converting a GenModel to an Xcore Model</span></h2>
	<p>
		To make it easy to migrate existing artifacts to Xcore, we've added migration support.
		It is integrated with the GenModel's exporter framework, so from the context menu of the Generator editor opened for a <code>*.genmodel</code> resource, you can invoke <code>Export Model...</code>.
		Suppose we did that for the <a href="http://help.eclipse.org/indigo/index.jsp?topic=/org.eclipse.emf.doc/tutorials/xlibmod/xlibmod.html">XML Schema-based library model</a>.
	</p>
	<img alt="XcoreExportGenModelToXcore.png" src="images/XcoreExportGenModelToXcore.png">

	<p>
		That will bring up the "Export EMF Model" wizard from which you can choose Xcore as the target.
	</p>
	<img alt="XcoreExportWizardExporterPage.png" src="images/XcoreExportWizardExporterPage.png">

	<p>
		The next page allows you to choose where the new Xcore resources will be saved.
	</p>
	<img alt="XcoreExportWizardDestinationPage.png" src="images/XcoreExportWizardDestinationPage.png">

	<p>
		The final page allows you to choose which packages to export and the name of the Xcore resource in which to save them.
	</p>
	<img alt="XcoreExportWizardFinalPage.png" src="images/XcoreExportWizardFinalPage.png">

	<p>
		Completing that page produces the following resource:
	</p>
	<img alt="XcoreConvertedSchemaLibraryModel.png" src="images/XcoreConvertedSchemaLibraryModel.png">

	<p>
		Notice all the annotations that capture details that would otherwise be missing:
	</p>
	<ul>
		<li>The <code>nsURI</code> of the model, which, if unspecified by an <code>Ecore</code> annotation, is just the fully qualified package name.</li>
		<li>The <code>ExtendedMetaData</code> annotations which record the mapping onto XML Schema.</li>
	</ul>

	<p>
		Notice too in the import directives that keywords can be used as identifiers when escaped with a <code>^</code>.
	</p>

	<h2><span id="Converting_an_Xcore_Model_to_a_GenModel">Converting an Xcore Model to a GenModel</span></h2>
	<p>
		If for some reason you need the legacy format, e.g., to use a tool which expects that format, you can convert your Xcore model to a GenModel using the importer framework.
		From the context menu for the <code>*.xcore</code> resource, you can create a new <code>*.genmodel</code> resource as follows:
	</p>
	<img alt="XcoreGenModelImportContextMenu.png" src="images/XcoreGenModelImportContextMenu.png">

	<p>
		This brings up the following wizard in which we can choose to create a new EMF Generator model:
	</p>
	<img alt="XcoreGenModelImportWizardSelectionPage.png" src="images/XcoreGenModelImportWizardSelectionPage.png">

	<p>
		Proceeding to the next page, where we can choose the location and name of the new <code>*.genmodel</code> resource.
	</p>
	<img alt="XcoreGenModelImportWizardGenModelNamePage.png" src="images/XcoreGenModelImportWizardGenModelNamePage.png">

	<p>
		Proceeding from there, we can choose which importer to use.
	</p>
	<img alt="XcoreGenModelImportWizardImporterSelectionPage.png" src="images/XcoreGenModelImportWizardImporterSelectionPage.png">

	<p>
		After that, we can choose which <code>*.xcore</code> resource to import.
		Note that one is already suggested because we have it selected in the package explore.
		Also note that you must hit the <code>Load</code> button in order to proceed from this page
	</p>
	<img alt="XcoreGenModelImportWizardSourceXcorePage.png" src="images/XcoreGenModelImportWizardSourceXcorePage.png">

	<p>
		That brings us to the final page where we can choose which packages to import and which to reuse from existing sources.
	</p>
	<img alt="XcoreGenModelImportWizardPackageSelectionPage.png" src="images/XcoreGenModelImportWizardPackageSelectionPage.png">

	<p>
		Given that the Xcore resource does physically contain a GenModel and an Ecore model, it should be possible in the future for any tool to consume Xcore resources directly.
	</p>

</body>

</html>